- mySQL 設置預設值 now()

  ```mysql
  CREATE TABLE foo (
      creation_time      DATETIME DEFAULT   CURRENT_TIMESTAMP,
      modification_time  DATETIME ON UPDATE CURRENT_TIMESTAMP
  )
  ```

- 新增欄位

  ```mysql
  ALTER TABLE vendors
  ADD COLUMN vendor_group INT NOT NULL;
  ```

## Trigger

> 資料表連鎖更動資料
>
> 資料庫的異動必須留下紀錄 → Log →追究責任
>
> **建立 Trigger 時一定要有文件！**否則不知道會動到哪些資料表
>
> ~~人眼檢查時很容易沒看到~~

```mysql
-- 把分號換成 $$
-- 建立一個獨立的 SQL Command 區段
DELIMITER $$
DELIMITER ; -- $$ 換回 ; 結束區段
```

- 只能在以下三種狀況觸發

  - insert
  	```mysql
      DELIMITER $$

      CREATE TRIGER tr_trigger_name
      AFTER INSERT 
      -- 在 INSERT 之後
      ON tableName FOR EACH ROW -- 針對 tableName 資料表的每一筆
      -- TRIGGER 要做的動作
      begin
      -- new儲存當前變動的值
        set @body = concat( '將 [', new.uid, ', ', new.cname, '] 加到userinfo資料表中'); 
        insert into log (body) values (@body); 
      end $$

      DELIMITER ;
    ```
    
  - delete
  
    ```mysql
    DELIMITER $$
    
      CREATE TRIGGER tr_log_userinfo_delete
      BEFORE DELETE 
      ON userinfo FOR EACH ROW
      begin
        set @body = concat( 
            '將 userinfo 的 [', 
            ifnull(old.uid, "null"),
            ', ',
            ifnull(old.cname, "null"),
            '] 刪除'); 
        insert into log (body) values (@body); 
      end $$
    
      DELIMITER ;
    ```
  
  - update
  
    ```mysql
    -- 需要處理 null 相關欄位
    delimiter $$
    create trigger tr_log_userinfo_update
    after UPDATE 
    on userinfo for each row 
    begin 
    	set @body = concat( 
            '將userinfo資料表中 [',
            ifnull(old.uid, "null"),
            ', ',
            ifnull(old.cname, "null"),
            '] 修改為  [',
            ifnull(new.uid, "null"),
            ', ',
            ifnull(new.cname, "null"), ']');
    	insert into log (body) values (@body); 
    end $$
    delimiter ;
    ```

- 保留字

  - new

    > 時的新資料

  - old

    > 被刪除的資料

- 中止異動的 trigger

  ```mysql
  DELIMITER $$
  CREATE TRIGGER tr_userinfo_multiupdate
  BEFORE UPDATE
  ON userinfo FOR EACH ROW
  BEGIN
  	SET @count = if(@count is null, 1, (@count+1));
      if @count >1 THEN
      	SIGNAL SQLSTATE "45001" SET MESSAGE_TEXT = "禁止大量異動";
      END IF;
  END $$
  DELIMITER ;
  ```

  - 在 update before 觸發

  - 設置變數計算 update 筆數

  - 兩筆以上停止

    - signal = 中斷 SQL Command 執行
    - sqlstate 錯誤代碼
    - set message_text = "回應內容"

    ```mysql
    signal sqlstate '大一點的數字(45001)' set message_text = "=自訂錯誤訊息";
    ```

- 取得發送指令的使用者

  ```mysql
  SELECT CURRENT_USER();
  ```

- 

## 暫存表

- 加快執行速度
- 資料表只存在記憶體裡面
  - 超出記憶體容量時會產生暫存檔在硬碟內
- 在後端執行指令
- 所有使用者使用完畢之後會自動刪除

## Procedure

- 在資料庫寫程式

- SQL Command 本身不是程式語言

  - 沒有宣告變數
  - 沒有流程控制
  - 沒有副程式

- 資料庫程式語言

  - T-SQL
  - Access
  - MySQL

- 使用Procedure

  ```mysql
  DELIMITER $$
  CREATE PROCEDURE pro_name(args1 type, args2 type,...)
  BEGIN
  	-- do somethings...
  END $$
  DELIMITER ;
  
  call pro_name(args1, args2, ...);
  ```

- example

  ```mysql
  DELIMITER $$
  
  CREATE PROCEDURE pro_getRegionUser(region varchar(20))
  BEGIN
  	SELECT * FROM vw_user WHERE address like concat(region, '%');
  END$$
  
  DELIMITER ;
  ```

- 參數類型

  - in

  - out

    > return value
    >
    > 只能回傳純量

    ```mysql
    DELIMITER $$
    
    CREATE PROCEDURE double_value(v int, out res int)
    begin
    	set res = v * 2;
    end$$
    
    DELIMITER ;
    
    
    set @res = 0;
    call double_value(10, @res);
    SELECT @res;
    ```

  - inout

## Function

- 有回傳值

- 建立

  ```mysql
  delimiter $$
  create function fn_add(v1 int, v2 int) returns int
  begin
  	return v1 + v2;
  end$$
  delimiter ;
  ```



## 變數宣告

```mysql
set @n = 1;
select @n := 1;

```

